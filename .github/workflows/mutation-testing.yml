name: Mutation Testing

on:
  schedule:
    - cron: '0 6 * * 1'  # Monday 06:00 UTC
  workflow_dispatch:
    inputs:
      file:
        description: 'Target file (e.g. lib/retry.sh). Empty = all lib files.'
        required: false
        type: string
      with-deletions:
        description: 'Include line-deletion mutations'
        required: false
        type: boolean
        default: false
      with-integration:
        description: 'Re-test survivors against integration tests'
        required: false
        type: boolean
        default: false

concurrency:
  group: mutation-testing-${{ github.event_name }}
  cancel-in-progress: true

jobs:
  mutate:
    runs-on: ubuntu-latest
    timeout-minutes: 240
    steps:
      - uses: actions/checkout@v4

      - name: Install bats-core
        run: sudo npm install -g bats

      - name: Ensure execute bits
        run: chmod +x claudeloop tests/mutate.sh

      - name: Debug stdin behavior on Linux
        run: |
          echo "=== Test 1: basic read from file redirect ==="
          printf 'n\n' > /tmp/test_input
          sh -c 'read -r x; echo "got: [$x]"' < /tmp/test_input

          echo "=== Test 2: exec 3<&0 + read <&3 ==="
          sh -c 'exec 3<&0; read -r x <&3; echo "got: [$x]"; exec 3<&-' < /tmp/test_input

          echo "=== Test 3: read after \$() subshell ==="
          sh -c '
            dummy=$(echo hello)
            read -r x
            echo "got: [$x]"
          ' < /tmp/test_input

          echo "=== Test 4: read <&3 after \$() with exec 0</dev/null ==="
          sh -c '
            exec 3<&0
            dummy=$(exec 0</dev/null; echo hello)
            read -r x <&3
            echo "got: [$x]"
            exec 3<&-
          ' < /tmp/test_input

          echo "=== Test 5: what does the test's sh -c actually see? ==="
          printf 'n\n' > /tmp/user_input
          cat > /tmp/mock_claude << 'MOCK'
          #!/bin/sh
          cat /dev/stdin > /dev/null
          COUNTER_FILE="/tmp/mock_call_count"
          count=0
          [ -f "$COUNTER_FILE" ] && count=$(cat "$COUNTER_FILE")
          count=$((count + 1))
          echo "$count" > "$COUNTER_FILE"
          case "$count" in
            1) printf '{"type":"assistant","message":{"role":"assistant","content":[{"type":"text","text":"## Phase 1: Setup\\nCreate project.\\n"}]}}\n' ;;
            2) printf '{"type":"assistant","message":{"role":"assistant","content":[{"type":"text","text":"FAIL\\nMissing stuff.\\n"}]}}\n' ;;
          esac
          MOCK
          chmod +x /tmp/mock_claude
          rm -f /tmp/mock_call_count

          sh -c '
            . lib/ui.sh
            . lib/parser.sh
            . lib/stream_processor.sh
            . lib/ai_parser.sh
            echo "DEBUG: fd0 before exec 3" >&2
            ls -la /proc/self/fd/0 >&2 2>/dev/null || true
            exec 3<&0
            echo "DEBUG: fd3 created" >&2
            ls -la /proc/self/fd/3 >&2 2>/dev/null || true
            # Simulate what ai_parse_and_verify does: call $() then read
            dummy=$(exec 0</dev/null; echo hello)
            echo "DEBUG: after subshell, reading from fd3..." >&2
            read -r answer <&3
            echo "DEBUG: read got: [$answer]" >&2
            exec 3<&-
          ' < /tmp/user_input 2>&1

          echo "=== Test 6: apply mutation and run specific test ==="
          sed -i 's/\[Nn]\*) exec 3<\&-; return 1/[Nn]*) exec 3<\&-; return 0/' lib/ai_parser.sh
          grep -n 'Nn.*return' lib/ai_parser.sh
          bats tests/test_ai_parser.sh --filter "exits when user says n" -T 2>&1 || echo "TEST_EXIT=$?"
          git checkout -- lib/ai_parser.sh

      - name: Run mutation tests
        id: mutate
        run: |
          ARGS=""
          [ -n "$FILE_INPUT" ] && ARGS="$FILE_INPUT"
          [ "$WITH_DELETIONS" = "true" ] && ARGS="$ARGS --with-deletions"
          [ "$WITH_INTEGRATION" = "true" ] && ARGS="$ARGS --with-integration"
          ./tests/mutate.sh $ARGS
        env:
          FILE_INPUT: ${{ inputs.file }}
          WITH_DELETIONS: ${{ inputs.with-deletions }}
          WITH_INTEGRATION: ${{ inputs.with-integration }}

      - name: Render report to job summary
        if: always()
        run: |
          if [ -f .claudeloop/mutation-report.md ]; then
            cat .claudeloop/mutation-report.md >> "$GITHUB_STEP_SUMMARY"
          else
            echo "## Mutation Testing" >> "$GITHUB_STEP_SUMMARY"
            if [ "$MUTATE_OUTCOME" = "failure" ]; then
              echo "Mutation testing failed. Check logs for details." >> "$GITHUB_STEP_SUMMARY"
            else
              echo "All mutants killed. Score: 100%" >> "$GITHUB_STEP_SUMMARY"
            fi
          fi
        env:
          MUTATE_OUTCOME: ${{ steps.mutate.outcome }}

      - name: Upload mutation report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: mutation-report
          path: .claudeloop/mutation-report.md
          if-no-files-found: ignore
