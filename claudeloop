#!/bin/sh

# ClaudeLoop - Phase-by-Phase Execution Tool
# Executes multi-phase plans by spawning fresh Claude instances per phase

set -eu

# Script directory
SCRIPT_DIR=$(cd "$(dirname "$0")" && pwd)

# Capture env vars before defaults (precedence: defaults → config → env → CLI)
_CL_PLAN_FILE="${PLAN_FILE:-}"
_CL_PROGRESS_FILE="${PROGRESS_FILE:-}"
_CL_MAX_RETRIES="${MAX_RETRIES:-}"
_CL_BASE_DELAY="${BASE_DELAY:-}"
_CL_MAX_DELAY="${MAX_DELAY:-}"
_CL_SIMPLE_MODE="${SIMPLE_MODE:-}"
_CL_PHASE_PROMPT_FILE="${PHASE_PROMPT_FILE:-}"
_CL_QUOTA_RETRY_INTERVAL="${QUOTA_RETRY_INTERVAL:-}"

# Source libraries
. "$SCRIPT_DIR/lib/parser.sh"
. "$SCRIPT_DIR/lib/dependencies.sh"
. "$SCRIPT_DIR/lib/progress.sh"
. "$SCRIPT_DIR/lib/retry.sh"
. "$SCRIPT_DIR/lib/ui.sh"
. "$SCRIPT_DIR/lib/prompt.sh"

# Default configuration
PLAN_FILE="PLAN.md"
PROGRESS_FILE="PROGRESS.md"
STATE_FILE=".claudeloop/state/current.json"
LOCK_FILE=".claudeloop/lock"
RESET_PROGRESS=false
START_PHASE=""
DRY_RUN=false
INTERRUPTED=false
CURRENT_PHASE=""
PHASE_PROMPT_FILE=""
SIMPLE_MODE=false
VERBOSE_MODE=false

# Print a message only when VERBOSE_MODE is true
log_verbose() {
  [ "$VERBOSE_MODE" = "true" ] && printf '[verbose] %s\n' "$*" >&2 || true
}

# Load .claudeloop.conf key=value config file (do NOT source)
load_config() {
  local conf_file=".claudeloop.conf"
  [ ! -f "$conf_file" ] && return 0

  local line key value
  while IFS= read -r line; do
    case "$line" in
      ''|'#'*) continue ;;
    esac
    key="${line%%=*}"
    value="${line#*=}"
    key=$(printf '%s' "$key" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    value=$(printf '%s' "$value" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    case "$key" in
      PLAN_FILE)         PLAN_FILE="$value" ;;
      PROGRESS_FILE)     PROGRESS_FILE="$value" ;;
      MAX_RETRIES)       MAX_RETRIES="$value" ;;
      SIMPLE_MODE)       SIMPLE_MODE="$value" ;;
      PHASE_PROMPT_FILE) PHASE_PROMPT_FILE="$value" ;;
      BASE_DELAY)             BASE_DELAY="$value" ;;
      MAX_DELAY)              MAX_DELAY="$value" ;;
      QUOTA_RETRY_INTERVAL)   QUOTA_RETRY_INTERVAL="$value" ;;
    esac
  done < "$conf_file"
}

# Save current state to state file
save_state() {
  mkdir -p "$(dirname "$STATE_FILE")"

  cat > "$STATE_FILE" << EOF
{
  "plan_file": "$PLAN_FILE",
  "progress_file": "$PROGRESS_FILE",
  "current_phase": "$CURRENT_PHASE",
  "interrupted": true,
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}
EOF
}

# Load state from state file
load_state() {
  if [ ! -f "$STATE_FILE" ]; then
    return 1
  fi

  # Simple parsing of JSON (basic implementation)
  if grep -q '"interrupted": true' "$STATE_FILE"; then
    print_warning "Found interrupted session"
    printf 'Resume from last checkpoint? (Y/n) '
    read -r response
    case "$response" in
      [Nn])
        rm -f "$STATE_FILE"
        return 1
        ;;
    esac
    return 0
  fi

  return 1
}

# Clear state file
clear_state() {
  rm -f "$STATE_FILE"
}

# Create lock file
create_lock() {
  local lock_dir
  lock_dir="$(dirname "$LOCK_FILE")"
  mkdir -p "$lock_dir"

  if [ -f "$LOCK_FILE" ]; then
    local pid
    pid=$(cat "$LOCK_FILE" 2>/dev/null)
    if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
      print_error "Another instance is running (PID: $pid)"
      exit 1
    else
      print_warning "Removing stale lock file"
      rm -f "$LOCK_FILE"
    fi
  fi

  echo $$ > "$LOCK_FILE"
}

# Remove lock file
remove_lock() {
  rm -f "$LOCK_FILE"
}

# Signal handler for graceful shutdown
handle_interrupt() {
  INTERRUPTED=true
  echo ""
  print_warning "Interrupt received (Ctrl+C)"
  print_warning "Saving state and shutting down gracefully..."
  log_verbose "handle_interrupt: CURRENT_PHASE=$CURRENT_PHASE"

  # Mark current phase as pending if it was in progress
  if [ -n "$CURRENT_PHASE" ]; then
    local _status
    _status=$(eval "echo \"\$PHASE_STATUS_$CURRENT_PHASE\"")
    if [ "$_status" = "in_progress" ]; then
      print_warning "Marking Phase $CURRENT_PHASE as pending for retry"
      eval "PHASE_STATUS_${CURRENT_PHASE}=pending"
      # Don't count this as an attempt since it was interrupted
      local _attempts
      _attempts=$(eval "echo \"\$PHASE_ATTEMPTS_$CURRENT_PHASE\"")
      eval "PHASE_ATTEMPTS_${CURRENT_PHASE}=$((_attempts - 1))"
    fi
  fi

  # Save progress
  write_progress "$PROGRESS_FILE" "$PLAN_FILE"

  # Save state for resume
  save_state

  # Cleanup
  remove_lock

  echo ""
  print_success "State saved successfully"
  print_success "Resume with: $0 --continue"
  exit 130
}

# Cleanup on exit
cleanup() {
  remove_lock
  if [ "$INTERRUPTED" = false ]; then
    clear_state
  fi
}

# Usage information
usage() {
  cat << EOF
ClaudeLoop - Phase-by-Phase Execution Tool

Usage: $(basename "$0") [OPTIONS]

Options:
  --plan <file>          Plan file to execute (default: PLAN.md)
  --progress <file>      Progress file (default: PROGRESS.md)
  --reset                Reset progress and start from beginning
  --continue             Continue from last checkpoint (default)
  --phase <n>            Start from specific phase number
  --dry-run              Validate plan without execution
  --phase-prompt <file>  Custom prompt template for phase execution
  --max-retries <n>      Maximum retry attempts per phase (default: 3)
  --quota-retry-interval <s>  Seconds to wait after quota limit error (default: 900)
  --simple               Use simple output mode (no colors/fancy UI)
  --verbose              Enable verbose debug output
  --help                 Show this help message

Examples:
  $(basename "$0") --plan my_plan.md
  $(basename "$0") --reset
  $(basename "$0") --phase 3 --continue

EOF
}

# Parse command-line arguments
parse_args() {
  while [ $# -gt 0 ]; do
    case "$1" in
      --plan)
        PLAN_FILE="$2"
        shift 2
        ;;
      --progress)
        PROGRESS_FILE="$2"
        shift 2
        ;;
      --reset)
        RESET_PROGRESS=true
        shift
        ;;
      --continue)
        # Default behavior
        shift
        ;;
      --phase)
        START_PHASE="$2"
        shift 2
        ;;
      --dry-run)
        DRY_RUN=true
        shift
        ;;
      --phase-prompt)
        PHASE_PROMPT_FILE="$2"
        shift 2
        ;;
      --max-retries)
        MAX_RETRIES="$2"
        shift 2
        ;;
      --quota-retry-interval)
        QUOTA_RETRY_INTERVAL="$2"
        shift 2
        ;;
      --simple)
        SIMPLE_MODE=true
        shift
        ;;
      --verbose)
        VERBOSE_MODE=true
        shift
        ;;
      --help|-h)
        usage
        exit 0
        ;;
      *)
        echo "Error: Unknown option $1" >&2
        usage
        exit 1
        ;;
    esac
  done
}

# Validate environment
validate_environment() {
  # Check if in git repository
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    print_error "Not in a git repository. ClaudeLoop requires git for safety."
    exit 1
  fi

  # Check for uncommitted changes
  if ! git diff-index --quiet HEAD -- 2>/dev/null; then
    print_warning "Uncommitted changes detected. Consider committing before starting."
    printf 'Continue anyway? (y/N) '
    read -r response
    case "$response" in
      [Yy]) ;;  # Continue
      *)
        echo "Aborted."
        exit 0
        ;;
    esac
  fi

  # Check if claude CLI is available
  if ! command -v claude > /dev/null 2>&1; then
    print_error "claude CLI not found. Please install it first."
    exit 1
  fi
}

# Execute a single phase
execute_phase() {
  local phase_num="$1"
  local title
  title=$(eval "echo \"\$PHASE_TITLE_$phase_num\"")
  local description
  description=$(eval "echo \"\$PHASE_DESCRIPTION_$phase_num\"")
  local log_file=".claudeloop/logs/phase-$phase_num.log"

  # Set current phase for interrupt handler
  CURRENT_PHASE="$phase_num"

  # Create log directory
  mkdir -p ".claudeloop/logs"

  log_verbose "execute_phase: phase=$phase_num title=$title"

  # Update status
  update_phase_status "$phase_num" "in_progress"
  write_progress "$PROGRESS_FILE" "$PLAN_FILE"

  print_phase_exec_header "$phase_num"

  # Construct prompt for Claude
  local prompt
  if [ -n "$PHASE_PROMPT_FILE" ]; then
    if ! prompt=$(build_phase_prompt "$PHASE_PROMPT_FILE" "$phase_num" "$title" "$description" "$PLAN_FILE"); then
      print_error "Failed to build prompt from template: $PHASE_PROMPT_FILE"
      return 1
    fi
  else
    prompt="You are executing Phase $phase_num of a multi-phase plan.

## Phase $phase_num: $title

$description

## Context
- This is a fresh Claude instance dedicated to this phase only
- Previous phases have been completed and committed to git
- Review recent git history and existing code before implementing
- When done, ensure all changes are tested and working
- Commit your changes when complete

## Task
Implement the above phase completely. Make sure to:
1. Read relevant existing code
2. Implement required changes
3. Test your implementation thoroughly
4. Commit your changes when complete"
  fi

  # Execute claude, capturing its exit status separately from tee
  # (pipeline exit status is tee's, not claude's — so save to temp file)
  local _exit_tmp
  _exit_tmp=$(mktemp)
  echo "Executing Claude CLI..."
  {
    _rc=0
    echo "$prompt" | claude --non-interactive 2>&1 || _rc=$?
    printf '%s\n' "$_rc" > "$_exit_tmp"
  } | tee "$log_file"

  local claude_exit=1
  if [ -f "$_exit_tmp" ]; then
    claude_exit=$(cat "$_exit_tmp")
    rm -f "$_exit_tmp"
  fi

  # Log rotation: keep last 500 lines if file exceeds limit
  local line_count
  line_count=$(wc -l < "$log_file")
  if [ "$line_count" -gt 500 ]; then
    tail -n 500 "$log_file" > "${log_file}.tmp" && mv "${log_file}.tmp" "$log_file"
    log_verbose "execute_phase: rotated log for phase $phase_num ($line_count → 500 lines)"
  fi

  if [ "$claude_exit" -eq 0 ]; then
    log_verbose "execute_phase: phase $phase_num succeeded"
    print_success "Phase $phase_num completed successfully"
    update_phase_status "$phase_num" "completed"
    write_progress "$PROGRESS_FILE" "$PLAN_FILE"
    CURRENT_PHASE=""
    return 0
  else
    log_verbose "execute_phase: phase $phase_num failed"
    print_error "Phase $phase_num failed"
    update_phase_status "$phase_num" "failed"
    write_progress "$PROGRESS_FILE" "$PLAN_FILE"
    CURRENT_PHASE=""
    return 1
  fi
}

# Main execution loop
main_loop() {
  local continue_execution=true

  while $continue_execution; do
    # Check for interruption
    if $INTERRUPTED; then
      print_warning "Execution interrupted"
      return 130
    fi

    # Find next runnable phase
    local next_phase
    log_verbose "main_loop: finding next runnable phase"
    if ! next_phase=$(find_next_phase); then
      # No runnable phases - check why
      local has_pending=false
      local has_failed=false
      local i=1

      while [ "$i" -le "$PHASE_COUNT" ]; do
        local _status
        _status=$(eval "echo \"\$PHASE_STATUS_$i\"")
        if [ "$_status" = "pending" ]; then
          has_pending=true
        fi
        if [ "$_status" = "failed" ]; then
          has_failed=true
        fi
        i=$((i + 1))
      done

      if ! $has_pending && ! $has_failed; then
        # All phases completed
        print_success "All phases completed!"
        return 0
      elif $has_pending; then
        print_error "Remaining phases are blocked by dependencies"
        return 1
      else
        print_error "Some phases failed and no more phases can run"
        return 1
      fi
    fi

    log_verbose "main_loop: next runnable phase is $next_phase"

    # Execute the next phase
    if execute_phase "$next_phase"; then
      log_verbose "main_loop: phase $next_phase succeeded, continuing"
      # Success - continue to next phase
      continue
    else
      local _log_file
      _log_file=".claudeloop/logs/phase-${next_phase}.log"
      if is_quota_error "$_log_file"; then
        # Quota error: restore attempt counter (same pattern as handle_interrupt)
        local _cur_attempts
        _cur_attempts=$(eval "echo \"\$PHASE_ATTEMPTS_$next_phase\"")
        eval "PHASE_ATTEMPTS_${next_phase}=$((_cur_attempts - 1))"
        log_verbose "main_loop: quota error on phase $next_phase, attempts restored to $((_cur_attempts - 1))"
        # Reset to pending so find_next_phase picks it up after the wait
        eval "PHASE_STATUS_${next_phase}=pending"
        write_progress "$PROGRESS_FILE" "$PLAN_FILE"
        print_quota_wait "$next_phase" "$QUOTA_RETRY_INTERVAL"
        sleep "$QUOTA_RETRY_INTERVAL"
        continue
      fi
      # Normal error: existing retry logic (unchanged)
      if should_retry_phase "$next_phase"; then
        local _attempts
        _attempts=$(eval "echo \"\$PHASE_ATTEMPTS_$next_phase\"")
        local delay
        delay=$(calculate_backoff "$_attempts")
        log_verbose "main_loop: scheduling retry of phase $next_phase in ${delay}s (attempt $_attempts)"
        print_warning "Retrying phase $next_phase after $delay seconds..."
        sleep "$delay"
        continue
      else
        print_error "Phase $next_phase failed after ${MAX_RETRIES} attempts"
        return 1
      fi
    fi
  done
}

# Main function
main() {
  # Set up signal handlers and cleanup
  trap handle_interrupt INT TERM
  trap cleanup EXIT

  # Load config file (defaults → config file)
  load_config

  # Apply env var overrides (env vars take priority over config file)
  [ -n "$_CL_PLAN_FILE" ]         && PLAN_FILE="$_CL_PLAN_FILE"
  [ -n "$_CL_PROGRESS_FILE" ]     && PROGRESS_FILE="$_CL_PROGRESS_FILE"
  [ -n "$_CL_MAX_RETRIES" ]       && MAX_RETRIES="$_CL_MAX_RETRIES"
  [ -n "$_CL_BASE_DELAY" ]        && BASE_DELAY="$_CL_BASE_DELAY"
  [ -n "$_CL_MAX_DELAY" ]         && MAX_DELAY="$_CL_MAX_DELAY"
  [ -n "$_CL_SIMPLE_MODE" ]       && SIMPLE_MODE="$_CL_SIMPLE_MODE"
  [ -n "$_CL_PHASE_PROMPT_FILE" ]       && PHASE_PROMPT_FILE="$_CL_PHASE_PROMPT_FILE"
  [ -n "$_CL_QUOTA_RETRY_INTERVAL" ]    && QUOTA_RETRY_INTERVAL="$_CL_QUOTA_RETRY_INTERVAL"

  # Parse CLI arguments (CLI takes priority over everything)
  parse_args "$@"

  # Print header
  print_header "$PLAN_FILE"

  # Check if plan file exists
  if [ ! -f "$PLAN_FILE" ]; then
    print_error "Plan file not found: $PLAN_FILE"
    exit 1
  fi

  # Validate phase prompt file if provided
  if [ -n "$PHASE_PROMPT_FILE" ] && [ ! -r "$PHASE_PROMPT_FILE" ]; then
    print_error "Phase prompt file not found or not readable: $PHASE_PROMPT_FILE"
    exit 1
  fi

  # Parse plan
  print_success "Parsing plan file: $PLAN_FILE"
  if ! parse_plan "$PLAN_FILE"; then
    print_error "Failed to parse plan file"
    exit 1
  fi

  echo "Found $PHASE_COUNT phases"
  echo ""

  # Validate environment (skip in dry-run)
  if ! $DRY_RUN; then
    validate_environment
  fi

  # Check for interrupted session (skip in dry-run and reset)
  if ! $DRY_RUN && ! $RESET_PROGRESS; then
    load_state || true
  fi

  # Initialize progress
  if $RESET_PROGRESS; then
    rm -f "$PROGRESS_FILE" "$STATE_FILE"
  fi

  init_progress "$PROGRESS_FILE"

  # Apply --phase N: mark phases before START_PHASE as completed (skip them)
  if [ -n "$START_PHASE" ]; then
    local i=1
    while [ "$i" -lt "$START_PHASE" ]; do
      eval "PHASE_STATUS_${i}='completed'"
      i=$((i + 1))
    done
    log_verbose "main: skipped phases 1-$((START_PHASE - 1)) (marked completed)"
  fi

  # Print phase list
  print_all_phases

  # Dry run mode
  if $DRY_RUN; then
    print_success "Dry run complete - plan is valid"
    exit 0
  fi

  # Create lock file to prevent concurrent runs
  create_lock

  print_warning "Press Ctrl+C at any time to stop (state will be saved)"
  echo ""

  # Execute phases
  local exit_code=0
  main_loop || exit_code=$?

  # Final progress update
  write_progress "$PROGRESS_FILE" "$PLAN_FILE"

  # Clear state on successful completion
  if [ $exit_code -eq 0 ]; then
    clear_state
  fi

  # Print final summary
  echo ""
  print_header "$PLAN_FILE"
  print_all_phases

  exit $exit_code
}

# Run main (skip if script is sourced for testing)
if [ "${_CLAUDELOOP_SOURCE_ONLY:-0}" != "1" ]; then
  main "$@"
fi
