#!/bin/sh

# ClaudeLoop - Phase-by-Phase Execution Tool
# Executes multi-phase plans by spawning fresh Claude instances per phase

VERSION="0.8.0"

set -eu

# Script directory
SCRIPT_DIR=$(cd "$(dirname "$0")" && pwd)

# Capture env vars before defaults (precedence: defaults → config → env → CLI)
_CL_PLAN_FILE="${PLAN_FILE:-}"
_CL_PROGRESS_FILE="${PROGRESS_FILE:-}"
_CL_MAX_RETRIES="${MAX_RETRIES:-}"
_CL_BASE_DELAY="${BASE_DELAY:-}"
_CL_MAX_DELAY="${MAX_DELAY:-}"
_CL_SIMPLE_MODE="${SIMPLE_MODE:-}"
_CL_PHASE_PROMPT_FILE="${PHASE_PROMPT_FILE:-}"
_CL_QUOTA_RETRY_INTERVAL="${QUOTA_RETRY_INTERVAL:-}"
_CL_SKIP_PERMISSIONS="${SKIP_PERMISSIONS:-}"
_CL_STREAM_TRUNCATE_LEN="${STREAM_TRUNCATE_LEN:-}"
_CL_MAX_PHASE_TIME="${MAX_PHASE_TIME:-}"

# Source libraries
. "$SCRIPT_DIR/lib/parser.sh"
. "$SCRIPT_DIR/lib/dependencies.sh"
. "$SCRIPT_DIR/lib/progress.sh"
. "$SCRIPT_DIR/lib/retry.sh"
. "$SCRIPT_DIR/lib/ui.sh"
. "$SCRIPT_DIR/lib/prompt.sh"
. "$SCRIPT_DIR/lib/stream_processor.sh"

# Default configuration
PLAN_FILE="PLAN.md"
PROGRESS_FILE=".claudeloop/PROGRESS.md"
STATE_FILE=".claudeloop/state/current.json"
LOCK_FILE=".claudeloop/lock"
RESET_PROGRESS=false
START_PHASE=""
DRY_RUN=false
INTERRUPTED=false
FORCE_MODE=false
FORCE_KILLED=false
CURRENT_PHASE=""
PHASE_PROMPT_FILE=""
SIMPLE_MODE=false
VERBOSE_MODE=false
SKIP_PERMISSIONS=false
STREAM_TRUNCATE_LEN=300
HOOKS_ENABLED=false
LIVE_LOG=""
MONITOR_MODE=false
MAX_PHASE_TIME=1800          # 30 min; kill claude after N seconds per phase (0=disabled)
CURRENT_PIPELINE_PID=""     # PID of running claude pipeline (last in pipeline), for interrupt cleanup
CURRENT_PIPELINE_PGID=""    # PGID of running claude pipeline (first in pipeline), for group kill

# Sentinels: set to 1 when the corresponding arg is explicitly passed via CLI
_CLI_PLAN_FILE="" _CLI_PROGRESS_FILE="" _CLI_MAX_RETRIES="" _CLI_SIMPLE_MODE=""
_CLI_PHASE_PROMPT_FILE="" _CLI_QUOTA_RETRY_INTERVAL="" _CLI_SKIP_PERMISSIONS=""
_CLI_MAX_PHASE_TIME=""

# Set to 1 in tests to bypass [ -t 0 ] TTY check in run_setup_wizard
_WIZARD_FORCE="${_WIZARD_FORCE:-}"

# Session-level non-interactive mode: auto-answer all prompts (NOT persisted to conf)
YES_MODE="${YES_MODE:-false}"
RESUME_MODE=false
MARK_COMPLETE_PHASE=""

# Print a message only when VERBOSE_MODE is true
log_verbose() {
  [ "$VERBOSE_MODE" = "true" ] && printf '[verbose] %s\n' "$*" >&2 || true
}

# Load .claudeloop.conf key=value config file (do NOT source)
load_config() {
  local conf_file=".claudeloop/.claudeloop.conf"
  [ ! -f "$conf_file" ] && return 0

  local line key value
  while IFS= read -r line; do
    case "$line" in
      ''|'#'*) continue ;;
    esac
    key="${line%%=*}"
    value="${line#*=}"
    key=$(printf '%s' "$key" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    value=$(printf '%s' "$value" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    case "$key" in
      PLAN_FILE)         PLAN_FILE="$value" ;;
      PROGRESS_FILE)     PROGRESS_FILE="$value" ;;
      MAX_RETRIES)       MAX_RETRIES="$value" ;;
      SIMPLE_MODE)       SIMPLE_MODE="$value" ;;
      PHASE_PROMPT_FILE) PHASE_PROMPT_FILE="$value" ;;
      BASE_DELAY)             BASE_DELAY="$value" ;;
      MAX_DELAY)              MAX_DELAY="$value" ;;
      QUOTA_RETRY_INTERVAL)   QUOTA_RETRY_INTERVAL="$value" ;;
      SKIP_PERMISSIONS)       SKIP_PERMISSIONS="$value" ;;
      STREAM_TRUNCATE_LEN)    STREAM_TRUNCATE_LEN="$value" ;;
      HOOKS_ENABLED)          HOOKS_ENABLED="$value" ;;
      MAX_PHASE_TIME)         MAX_PHASE_TIME="$value" ;;
    esac
  done < "$conf_file"
}

# Replace or append a key=value line in the conf file (POSIX, no sed -i)
# Values containing sed metacharacters (&, \, |) are escaped before substitution.
update_conf_key() {
  local file="$1" key="$2" value="$3" tmp escaped
  tmp="${file}.tmp"
  escaped=$(printf '%s\n' "$value" | sed 's/[\\&|]/\\&/g')
  if grep -q "^${key}=" "$file" 2>/dev/null; then
    sed "s|^${key}=.*|${key}=${escaped}|" "$file" > "$tmp" && mv "$tmp" "$file"
  else
    printf '%s=%s\n' "$key" "$value" >> "$file"
  fi
}

# Create or update .claudeloop.conf after arg parsing
write_config() {
  local conf_file=".claudeloop/.claudeloop.conf"

  # Never write config during dry-run
  $DRY_RUN && return 0

  mkdir -p ".claudeloop"

  if [ ! -f "$conf_file" ]; then
    # First run: create conf with all current persistable settings
    {
      printf '# claudeloop configuration — edit or delete freely\n'
      printf 'PLAN_FILE=%s\n'        "$PLAN_FILE"
      printf 'PROGRESS_FILE=%s\n'    "$PROGRESS_FILE"
      printf 'MAX_RETRIES=%s\n'      "$MAX_RETRIES"
      printf 'SIMPLE_MODE=%s\n'      "$SIMPLE_MODE"
      printf 'SKIP_PERMISSIONS=%s\n' "$SKIP_PERMISSIONS"
      printf 'BASE_DELAY=%s\n'       "$BASE_DELAY"
      printf 'MAX_DELAY=%s\n'        "$MAX_DELAY"
      printf 'STREAM_TRUNCATE_LEN=%s\n' "$STREAM_TRUNCATE_LEN"
      printf 'MAX_PHASE_TIME=%s\n'      "$MAX_PHASE_TIME"
      [ -n "$PHASE_PROMPT_FILE" ]    && printf 'PHASE_PROMPT_FILE=%s\n'    "$PHASE_PROMPT_FILE"
      [ -n "$QUOTA_RETRY_INTERVAL" ] && printf 'QUOTA_RETRY_INTERVAL=%s\n' "$QUOTA_RETRY_INTERVAL"
    } > "$conf_file"
    print_success "Created .claudeloop/.claudeloop.conf"
    return 0
  fi

  # Existing conf: update only CLI-set keys
  [ -n "$_CLI_PLAN_FILE" ]            && update_conf_key "$conf_file" PLAN_FILE "$PLAN_FILE"
  [ -n "$_CLI_PROGRESS_FILE" ]        && update_conf_key "$conf_file" PROGRESS_FILE "$PROGRESS_FILE"
  [ -n "$_CLI_MAX_RETRIES" ]          && update_conf_key "$conf_file" MAX_RETRIES "$MAX_RETRIES"
  [ -n "$_CLI_SIMPLE_MODE" ]          && update_conf_key "$conf_file" SIMPLE_MODE "$SIMPLE_MODE"
  [ -n "$_CLI_PHASE_PROMPT_FILE" ]    && update_conf_key "$conf_file" PHASE_PROMPT_FILE "$PHASE_PROMPT_FILE"
  [ -n "$_CLI_QUOTA_RETRY_INTERVAL" ] && update_conf_key "$conf_file" QUOTA_RETRY_INTERVAL "$QUOTA_RETRY_INTERVAL"
  [ -n "$_CLI_SKIP_PERMISSIONS" ]     && update_conf_key "$conf_file" SKIP_PERMISSIONS "$SKIP_PERMISSIONS"
  [ -n "$_CLI_MAX_PHASE_TIME" ]       && update_conf_key "$conf_file" MAX_PHASE_TIME "$MAX_PHASE_TIME"
  return 0
}

# Interactive first-run wizard. Prompts for each configurable setting.
# Only runs when: no .claudeloop.conf, stdin is a tty (or _WIZARD_FORCE=1), not --dry-run.
# Mutates globals directly; write_config() persists them immediately after.
run_setup_wizard() {
  local conf_file=".claudeloop/.claudeloop.conf"
  [ -f "$conf_file" ] && return 0
  $DRY_RUN && return 0
  [ -z "$_WIZARD_FORCE" ] && ! [ -t 0 ] && return 0

  printf '\nWelcome to claudeloop! Let'"'"'s configure your project.\n'
  printf 'Press Enter to accept the default [shown in brackets].\n\n'

  local response

  # PLAN_FILE
  if [ -n "$_CLI_PLAN_FILE" ]; then
    printf 'Plan file: using --plan %s\n' "$PLAN_FILE"
  else
    printf 'Plan file [%s]: ' "$PLAN_FILE"
    read -r response || return 0
    [ -n "$response" ] && PLAN_FILE="$response"
  fi

  # PROGRESS_FILE
  if [ -n "$_CLI_PROGRESS_FILE" ]; then
    printf 'Progress file: using --progress %s\n' "$PROGRESS_FILE"
  else
    printf 'Progress file [%s]: ' "$PROGRESS_FILE"
    read -r response || return 0
    [ -n "$response" ] && PROGRESS_FILE="$response"
  fi

  # MAX_RETRIES
  if [ -n "$_CLI_MAX_RETRIES" ]; then
    printf 'Max retries: using --max-retries %s\n' "$MAX_RETRIES"
  else
    printf 'Max retries on failure [%s]: ' "$MAX_RETRIES"
    read -r response || return 0
    if [ -n "$response" ]; then
      case "$response" in
        *[!0-9]*) ;;             # non-digit chars: keep default
        *) MAX_RETRIES="$response" ;;
      esac
    fi
  fi

  # QUOTA_RETRY_INTERVAL
  if [ -n "$_CLI_QUOTA_RETRY_INTERVAL" ]; then
    printf 'Quota retry interval: using --quota-retry-interval %s\n' "$QUOTA_RETRY_INTERVAL"
  else
    printf 'Quota wait after API limit, seconds [%s]: ' "$QUOTA_RETRY_INTERVAL"
    read -r response || return 0
    if [ -n "$response" ]; then
      case "$response" in
        *[!0-9]*) ;;             # non-digit chars: keep default
        *) QUOTA_RETRY_INTERVAL="$response" ;;
      esac
    fi
  fi

  # SIMPLE_MODE
  if [ -n "$_CLI_SIMPLE_MODE" ]; then
    printf 'Simple mode: using --simple\n'
  else
    printf 'Simple output, no colors (true/false) [%s]: ' "$SIMPLE_MODE"
    read -r response || return 0
    case "$response" in
      true|false) SIMPLE_MODE="$response" ;;
    esac
  fi

  # SKIP_PERMISSIONS
  if [ -n "$_CLI_SKIP_PERMISSIONS" ]; then
    printf 'Skip permissions: using --dangerously-skip-permissions\n'
  else
    printf 'Skip write permission prompts (true/false) [%s]: ' "$SKIP_PERMISSIONS"
    read -r response || return 0
    case "$response" in
      true|false) SKIP_PERMISSIONS="$response" ;;
    esac
  fi

  # PHASE_PROMPT_FILE
  if [ -n "$_CLI_PHASE_PROMPT_FILE" ]; then
    printf 'Phase prompt: using --phase-prompt %s\n' "$PHASE_PROMPT_FILE"
  else
    local prompt_default="${PHASE_PROMPT_FILE:-none}"
    printf 'Phase prompt template file [%s]: ' "$prompt_default"
    read -r response || return 0
    [ -n "$response" ] && [ "$response" != "none" ] && PHASE_PROMPT_FILE="$response"
  fi

  printf '\n'
}

# Save current state to state file
save_state() {
  mkdir -p "$(dirname "$STATE_FILE")"

  cat > "$STATE_FILE" << EOF
{
  "plan_file": "$PLAN_FILE",
  "progress_file": "$PROGRESS_FILE",
  "current_phase": "$CURRENT_PHASE",
  "interrupted": true,
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}
EOF
}

# Load state from state file
load_state() {
  if [ ! -f "$STATE_FILE" ]; then
    return 1
  fi

  # Simple parsing of JSON (basic implementation)
  if grep -q '"interrupted": true' "$STATE_FILE"; then
    _phase=$(grep '"current_phase"' "$STATE_FILE" | sed 's/.*"current_phase": *"\([^"]*\)".*/\1/')

    print_warning "Found interrupted session"
    if [ -n "$_phase" ]; then
      _title=$(eval "echo \"\$PHASE_TITLE_$(phase_to_var "$_phase")\"")
      printf '  Phase %s: %s\n' "$_phase" "$_title"
    fi
    if ! [ -t 0 ] || [ "$YES_MODE" = "true" ]; then
      response="y"
    else
      printf 'Resume from last checkpoint? (Y/n) '
      read -r response
    fi
    case "$response" in
      [Nn])
        rm -f "$STATE_FILE"
        return 1
        ;;
    esac
    return 0
  fi

  return 1
}

# Clear state file
clear_state() {
  rm -f "$STATE_FILE"
}

# Create lock file
create_lock() {
  local lock_dir
  lock_dir="$(dirname "$LOCK_FILE")"
  mkdir -p "$lock_dir"

  if [ -f "$LOCK_FILE" ]; then
    local pid
    pid=$(cat "$LOCK_FILE" 2>/dev/null)
    if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
      if [ "$FORCE_MODE" = "true" ]; then
        print_warning "Killing existing instance (PID: $pid) — progress is preserved"
        kill "$pid" 2>/dev/null || true
        local _wait=0
        while [ "$_wait" -lt 10 ] && kill -0 "$pid" 2>/dev/null; do
          sleep 1
          _wait=$((_wait + 1))
        done
        kill -9 "$pid" 2>/dev/null || true
        rm -f "$LOCK_FILE"
        FORCE_KILLED=true
      else
        print_error "Another instance is running (PID: $pid). Use --force to kill it, or run 'kill $pid' to stop it manually."
        exit 1
      fi
    else
      print_warning "Removing stale lock file"
      rm -f "$LOCK_FILE"
    fi
  fi

  echo $$ > "$LOCK_FILE"
}

# Remove lock file
remove_lock() {
  rm -f "$LOCK_FILE"
}

# Signal handler for graceful shutdown
handle_interrupt() {
  # Kill running claude pipeline immediately (don't wait for it to clean up)
  if [ -n "${CURRENT_PIPELINE_PID:-}" ]; then
    kill -TERM "$CURRENT_PIPELINE_PID" 2>/dev/null || true
    if [ -n "${CURRENT_PIPELINE_PGID:-}" ] && [ "${CURRENT_PIPELINE_PGID:-0}" -gt 1 ]; then
      kill -TERM -- "-$CURRENT_PIPELINE_PGID" 2>/dev/null || true
    fi
    CURRENT_PIPELINE_PID=""
    CURRENT_PIPELINE_PGID=""
  fi
  INTERRUPTED=true
  echo ""
  print_warning "Interrupt received (Ctrl+C)"
  print_warning "Saving state and shutting down gracefully..."
  log_verbose "handle_interrupt: CURRENT_PHASE=$CURRENT_PHASE"

  # Mark current phase as pending if it was in progress
  if [ -n "$CURRENT_PHASE" ]; then
    local _cpv
    _cpv=$(phase_to_var "$CURRENT_PHASE")
    local _status
    _status=$(eval "echo \"\$PHASE_STATUS_${_cpv}\"")
    if [ "$_status" = "in_progress" ]; then
      print_warning "Marking Phase $CURRENT_PHASE as pending for retry"
      eval "PHASE_STATUS_${_cpv}=pending"
      # Don't count this as an attempt since it was interrupted
      local _attempts
      _attempts=$(eval "echo \"\$PHASE_ATTEMPTS_${_cpv}\"")
      eval "PHASE_ATTEMPTS_${_cpv}=$((_attempts - 1))"
      eval "PHASE_ATTEMPT_TIME_${_cpv}_${_attempts}=''"
    fi
  fi

  # Save progress
  write_progress "$PROGRESS_FILE" "$PLAN_FILE"

  # Save state for resume
  save_state

  # Cleanup
  remove_lock

  echo ""
  print_success "State saved successfully"
  print_success "Resume with: $0 --continue"
  exit 130
}

# Cleanup on exit
cleanup() {
  remove_lock
  if [ "$INTERRUPTED" = false ]; then
    clear_state
  fi
}

# Usage information
usage() {
  print_logo
  cat << EOF
ClaudeLoop - Phase-by-Phase Execution Tool

Usage: $(basename "$0") [OPTIONS]

Options:
  --plan <file>          Plan file to execute (default: PLAN.md)
  --progress <file>      Progress file (default: PROGRESS.md)
  --reset                Reset progress and start from beginning
  --continue             Continue from last checkpoint (default)
  --phase <n>            Start from specific phase number
  --mark-complete <n>    Mark a phase as completed (use after a phase was done but logged as failed)
  --dry-run              Validate plan without execution
  --phase-prompt <file>  Custom prompt template for phase execution
  --max-retries <n>      Maximum retry attempts per phase (default: 5)
  --quota-retry-interval <s>  Seconds to wait after quota limit error (default: 900)
  --max-phase-time <s>   Kill claude after N seconds per phase, then retry (0=disabled, default 1800)
  --simple               Use simple output mode (no colors/fancy UI)
  --verbose              Enable verbose debug output
  --force                Kill any running instance and take over (preserves progress)
  --yes, -y              Non-interactive mode: auto-answer all prompts
                         (enabled automatically when running inside Claude Code)
  --dangerously-skip-permissions  Pass --dangerously-skip-permissions to claude
  --monitor              Follow live output of a running claudeloop instance
  --version, -V          Print version and exit
  --help                 Show this help message

Examples:
  $(basename "$0") --plan my_plan.md
  $(basename "$0") --reset
  $(basename "$0") --phase 3 --continue

EOF
}

# Parse command-line arguments
parse_args() {
  while [ $# -gt 0 ]; do
    case "$1" in
      --plan)
        PLAN_FILE="$2"; _CLI_PLAN_FILE=1
        shift 2
        ;;
      --progress)
        PROGRESS_FILE="$2"; _CLI_PROGRESS_FILE=1
        shift 2
        ;;
      --reset)
        RESET_PROGRESS=true
        shift
        ;;
      --continue)
        # Default behavior
        shift
        ;;
      --phase)
        START_PHASE="$2"
        shift 2
        ;;
      --mark-complete)
        MARK_COMPLETE_PHASE="$2"
        shift 2
        ;;
      --dry-run)
        DRY_RUN=true
        shift
        ;;
      --phase-prompt)
        PHASE_PROMPT_FILE="$2"; _CLI_PHASE_PROMPT_FILE=1
        shift 2
        ;;
      --max-retries)
        MAX_RETRIES="$2"; _CLI_MAX_RETRIES=1
        shift 2
        ;;
      --quota-retry-interval)
        QUOTA_RETRY_INTERVAL="$2"; _CLI_QUOTA_RETRY_INTERVAL=1
        shift 2
        ;;
      --max-phase-time)
        MAX_PHASE_TIME="$2"; _CLI_MAX_PHASE_TIME=1
        shift 2
        ;;
      --simple)
        SIMPLE_MODE=true; _CLI_SIMPLE_MODE=1
        shift
        ;;
      --verbose)
        VERBOSE_MODE=true
        shift
        ;;
      --force)
        FORCE_MODE=true
        shift
        ;;
      --yes|-y)
        YES_MODE=true
        shift
        ;;
      --dangerously-skip-permissions)
        SKIP_PERMISSIONS=true; _CLI_SKIP_PERMISSIONS=1
        shift
        ;;
      --version|-V)
        printf '%s\n' "$VERSION"
        exit 0
        ;;
      --monitor)
        MONITOR_MODE=true
        shift
        ;;
      --help|-h)
        usage
        exit 0
        ;;
      *)
        echo "Error: Unknown option $1" >&2
        usage
        exit 1
        ;;
    esac
  done
}

# Validate environment
validate_environment() {
  # Check if in git repository
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    print_error "Not in a git repository. ClaudeLoop requires git for safety."
    if ! [ -t 0 ] || [ "$YES_MODE" = "true" ]; then
      response="y"
    else
      printf 'Initialize a git repository here? (Y/n) '
      read -r response
    fi
    case "$response" in
      [Nn])
        echo "Aborted."
        exit 1
        ;;
      *)
        git init .
        print_success "Initialized git repository"
        ;;
    esac
  fi

  # Check for uncommitted changes
  if ! git diff-index --quiet HEAD -- 2>/dev/null; then
    if [ "$RESUME_MODE" = "true" ]; then
      print_warning "Uncommitted changes detected (resuming existing session)."
      # Continue without prompting — changes are from prior session
    elif [ -t 0 ] && [ "$YES_MODE" = "false" ]; then
      print_warning "Uncommitted changes detected. Consider committing before starting."
      printf 'Continue anyway? (y/N) '
      read -r response
      case "$response" in
        [Yy]) ;;
        *) echo "Aborted."; exit 0 ;;
      esac
    elif [ "$YES_MODE" = "true" ]; then
      : # continue — unattended mode
    else
      print_error "Uncommitted changes detected. Use --yes to proceed non-interactively."
      exit 1
    fi
  fi

  # Check if claude CLI is available
  if ! command -v claude > /dev/null 2>&1; then
    print_error "claude CLI not found. Please install it first."
    exit 1
  fi

}

# Offer to set up .gitignore for claudeloop artifacts
setup_project() {
  if ! grep -qF '.claudeloop' .gitignore 2>/dev/null; then
    if [ ! -f ".gitignore" ]; then
      if [ -t 0 ]; then
        printf 'No .gitignore found. Create one? (Y/n) '
        read -r response || true
        case "$response" in
          [Nn]) return 0 ;;
        esac
      fi
      printf '# claudeloop runtime\n.claudeloop/\n' > .gitignore
      print_success "Created .gitignore"
      _add_platform_gitignore silent
    else
      if [ -t 0 ]; then
        printf 'Add .claudeloop/ to .gitignore? (Y/n) '
        read -r response || true
        case "$response" in
          [Nn]) return 0 ;;
        esac
      fi
      printf '\n# claudeloop runtime\n.claudeloop/\n' >> .gitignore
      print_success "Added .claudeloop/ to .gitignore"
      _add_platform_gitignore silent
    fi
  fi
}

# $1: "silent" to skip prompting (used when patching an existing .gitignore)
_add_platform_gitignore() {
  local os silent
  silent="${1:-}"
  os=$(uname -s 2>/dev/null) || return 0
  case "$os" in
    Darwin)
      if [ "$silent" = "silent" ]; then
        printf '\n# macOS\n.DS_Store\n._*\n' >> .gitignore
      else
        if ! [ -t 0 ] || [ "$YES_MODE" = "true" ]; then
          response="y"
        else
          printf 'Add macOS-specific ignores (.DS_Store, ._*)? (Y/n) '
          read -r response || return 0
        fi
        case "$response" in
          [Nn]) ;;
          *) printf '\n# macOS\n.DS_Store\n._*\n' >> .gitignore ;;
        esac
      fi
      ;;
    MINGW*|CYGWIN*|MSYS*)
      if [ "$silent" = "silent" ]; then
        printf '\n# Windows\nThumbs.db\ndesktop.ini\n' >> .gitignore
      else
        if ! [ -t 0 ] || [ "$YES_MODE" = "true" ]; then
          response="y"
        else
          printf 'Add Windows-specific ignores (Thumbs.db, desktop.ini)? (Y/n) '
          read -r response || return 0
        fi
        case "$response" in
          [Nn]) ;;
          *) printf '\n# Windows\nThumbs.db\ndesktop.ini\n' >> .gitignore ;;
        esac
      fi
      ;;
  esac
}

# Execute a single phase
execute_phase() {
  local phase_num="$1"
  local _epv
  _epv=$(phase_to_var "$phase_num")
  local title
  title=$(eval "echo \"\$PHASE_TITLE_${_epv}\"")
  local description
  description=$(eval "echo \"\$PHASE_DESCRIPTION_${_epv}\"")
  local log_file=".claudeloop/logs/phase-$phase_num.log"
  local raw_log=".claudeloop/logs/phase-$phase_num.raw.json"
  local start_ts duration

  # Set current phase for interrupt handler
  CURRENT_PHASE="$phase_num"

  # Create log directory
  mkdir -p ".claudeloop/logs"

  log_verbose "execute_phase: phase=$phase_num title=$title"

  # Update status
  update_phase_status "$phase_num" "in_progress"
  write_progress "$PROGRESS_FILE" "$PLAN_FILE"

  local attempt
  attempt=$(eval "echo \"\$PHASE_ATTEMPTS_${_epv}\"")
  start_ts=$(date '+%s')

  print_phase_exec_header "$phase_num"

  # Construct prompt for Claude
  local prompt
  if [ -n "$PHASE_PROMPT_FILE" ]; then
    if ! prompt=$(build_phase_prompt "$PHASE_PROMPT_FILE" "$phase_num" "$title" "$description" "$PLAN_FILE"); then
      print_error "Failed to build prompt from template: $PHASE_PROMPT_FILE"
      return 1
    fi
  else
    prompt="You are executing Phase $phase_num of a multi-phase plan.

## Phase $phase_num: $title

$description

## Context
- This is a fresh Claude instance dedicated to this phase only
- Previous phases have been completed and committed to git
- Review recent git history and existing code before implementing
- When done, ensure all changes are tested and working
- Commit your changes when complete

## Task
Implement the above phase completely. Make sure to:
1. Read relevant existing code
2. Implement required changes
3. Test your implementation thoroughly
4. Commit your changes when complete"
  fi

  # Archive previous attempt log and inject context into prompt on retry
  if [ "$attempt" -gt 1 ] && [ -f "$log_file" ]; then
    local _prev_attempt_log
    _prev_attempt_log="${log_file%.log}.attempt-$((attempt - 1)).log"
    cp "$log_file" "$_prev_attempt_log"

    # Extract response section from archived log for context injection
    local _prev_context
    _prev_context=$(awk '
      /^=== RESPONSE ===$/ { found=1; next }
      /^=== EXECUTION END/ { exit }
      found { print }
    ' "$_prev_attempt_log" | tail -n 80)

    if [ -n "$_prev_context" ]; then
      prompt="${prompt}

## Previous Attempt Failed (attempt $((attempt - 1)))

The previous attempt exited without completing the phase. Here is the tail of what happened:

\`\`\`
${_prev_context}
\`\`\`

Learn from the above. Do not repeat the same mistakes. Address any errors shown before proceeding."
    fi
  fi

  # Write metadata + prompt header to log (overwrite previous content)
  {
    printf '=== EXECUTION START phase=%s attempt=%s time=%s ===\n' \
      "$phase_num" "$attempt" "$(date '+%Y-%m-%dT%H:%M:%S')"
    printf '=== PROMPT ===\n'
    printf '%s\n' "$prompt"
    printf '=== RESPONSE ===\n'
  } > "$log_file"

  # Execute claude with stream-json output, pipe through stream processor (backgrounded for
  # interruptibility and timeout support)
  local _exit_tmp _claude_debug_flag
  _exit_tmp=$(mktemp)
  _claude_debug_flag=""
  if [ "$VERBOSE_MODE" = "true" ]; then
    _claude_debug_flag="--debug-file .claudeloop/logs/phase-$phase_num.claude.debug"
  fi
  echo "Executing Claude CLI..."
  [ -n "${LIVE_LOG:-}" ] && echo "Executing Claude CLI..." >> "$LIVE_LOG" || true
  CURRENT_PIPELINE_PID=""
  CURRENT_PIPELINE_PGID=""
  # Use job control (set -m) so the background pipeline gets its own process group.
  # This lets the timer (and handle_interrupt) kill the entire pipeline by PGID,
  # not just the last process. Without set -m, kill -TERM $! only kills the last
  # process; with set -m, kill -TERM -- -$PGID kills every process in the job.
  set -m
  {
    _rc=0
    unset CLAUDECODE   # strip Claude Code marker — nested claude invocations require it unset
    if [ "$SKIP_PERMISSIONS" = "true" ]; then
      # shellcheck disable=SC2086
      echo "$prompt" | claude --print --dangerously-skip-permissions \
        --output-format=stream-json --verbose --include-partial-messages \
        $_claude_debug_flag 2>&1 || _rc=$?
    else
      # shellcheck disable=SC2086
      echo "$prompt" | claude --print \
        --output-format=stream-json --verbose --include-partial-messages \
        $_claude_debug_flag 2>&1 || _rc=$?
    fi
    printf '%s\n' "$_rc" > "$_exit_tmp"
  } | process_stream_json "$log_file" "$raw_log" "$HOOKS_ENABLED" "${LIVE_LOG:-}" &
  CURRENT_PIPELINE_PID=$!
  # With set -m the pipeline's PGID = PID of the first process (jobs -p shows it)
  CURRENT_PIPELINE_PGID=$(jobs -p 2>/dev/null | tr -d '[:space:]')
  set +m

  # Phase timeout: kill entire pipeline PGID after MAX_PHASE_TIME seconds (0 = disabled)
  local _timer_pid _pl_pid _pl_pgid
  _timer_pid=""
  _pl_pid="$CURRENT_PIPELINE_PID"
  _pl_pgid="$CURRENT_PIPELINE_PGID"
  if [ "$MAX_PHASE_TIME" -gt 0 ] 2>/dev/null; then
    ( sleep "$MAX_PHASE_TIME" && kill -TERM -- "-${_pl_pgid}" 2>/dev/null ) >/dev/null 2>&1 &
    _timer_pid=$!
  fi

  wait "$CURRENT_PIPELINE_PID" || true   # || true required: set -eu is active
  CURRENT_PIPELINE_PID=""
  CURRENT_PIPELINE_PGID=""

  # Cancel timer if phase completed before timeout
  if [ -n "$_timer_pid" ]; then
    kill "$_timer_pid" 2>/dev/null || true
    wait "$_timer_pid" 2>/dev/null || true
    _timer_pid=""
  fi

  local claude_exit=1
  if [ -f "$_exit_tmp" ]; then
    claude_exit=$(cat "$_exit_tmp")
    rm -f "$_exit_tmp"
  fi

  # Write metadata footer to log
  end_ts=$(date '+%s')
  duration=$((end_ts - start_ts))
  printf '=== EXECUTION END exit_code=%s duration=%ss time=%s ===\n' \
    "$claude_exit" "$duration" "$(date '+%Y-%m-%dT%H:%M:%S')" >> "$log_file"

  # Log rotation: preserve header up to RESPONSE marker, keep last 500 response lines
  local response_header_lines response_lines total_lines
  response_header_lines=$(grep -n '^=== RESPONSE ===$' "$log_file" | head -1 | cut -d: -f1)
  if [ -n "$response_header_lines" ]; then
    total_lines=$(wc -l < "$log_file")
    response_lines=$((total_lines - response_header_lines))
    if [ "$response_lines" -gt 500 ]; then
      header=$(head -n "$response_header_lines" "$log_file")
      tail_content=$(tail -n 500 "$log_file")
      printf '%s\n%s\n' "$header" "$tail_content" > "${log_file}.tmp" && mv "${log_file}.tmp" "$log_file"
      log_verbose "execute_phase: rotated log for phase $phase_num ($response_lines → 500 response lines)"
    fi
  else
    # Old-format log: fall back to original rotation
    line_count=$(wc -l < "$log_file")
    if [ "$line_count" -gt 500 ]; then
      tail -n 500 "$log_file" > "${log_file}.tmp" && mv "${log_file}.tmp" "$log_file"
      log_verbose "execute_phase: rotated log for phase $phase_num ($line_count → 500 lines)"
    fi
  fi

  # Empty log means Claude produced no output — always a failure
  if is_empty_log "$log_file"; then
    print_error "Phase $phase_num: Claude produced no output (empty log)."
    update_phase_status "$phase_num" "failed"
    write_progress "$PROGRESS_FILE" "$PLAN_FILE"
    CURRENT_PHASE=""
    return 1
  fi

  if [ "$claude_exit" -eq 0 ]; then
    if is_permission_error "$log_file"; then
      log_verbose "execute_phase: phase $phase_num exited 0 but requested permissions"
      print_error "Phase $phase_num: Claude requested write permissions but none were granted."
      print_error "Re-run with --dangerously-skip-permissions to bypass permission prompts."
      update_phase_status "$phase_num" "failed"
      write_progress "$PROGRESS_FILE" "$PLAN_FILE"
      CURRENT_PHASE=""
      return 1
    fi
    log_verbose "execute_phase: phase $phase_num succeeded"
    print_success "Phase $phase_num completed successfully"
    update_phase_status "$phase_num" "completed"
    write_progress "$PROGRESS_FILE" "$PLAN_FILE"
    CURRENT_PHASE=""
    return 0
  else
    if has_successful_session "$log_file"; then
      log_verbose "execute_phase: phase $phase_num exited non-zero ($claude_exit) but successful session detected"
      print_warning "Phase $phase_num: Claude exited with code $claude_exit but a successful session was detected — treating as completed."
      update_phase_status "$phase_num" "completed"
      write_progress "$PROGRESS_FILE" "$PLAN_FILE"
      CURRENT_PHASE=""
      return 0
    fi
    log_verbose "execute_phase: phase $phase_num failed"
    print_error "Phase $phase_num failed"
    update_phase_status "$phase_num" "failed"
    write_progress "$PROGRESS_FILE" "$PLAN_FILE"
    CURRENT_PHASE=""
    return 1
  fi
}

# Main execution loop
main_loop() {
  local continue_execution=true

  while $continue_execution; do
    # Check for interruption
    if $INTERRUPTED; then
      print_warning "Execution interrupted"
      return 130
    fi

    # Find next runnable phase
    local next_phase
    log_verbose "main_loop: finding next runnable phase"
    if ! next_phase=$(find_next_phase); then
      # No runnable phases - check why
      local has_pending=false
      local has_failed=false

      for _ml_phase in $PHASE_NUMBERS; do
        local _status
        _status=$(eval "echo \"\$PHASE_STATUS_$(phase_to_var "$_ml_phase")\"")
        if [ "$_status" = "pending" ]; then
          has_pending=true
        fi
        if [ "$_status" = "failed" ]; then
          has_failed=true
        fi
      done

      if ! $has_pending && ! $has_failed; then
        # All phases completed
        print_success "All phases completed!"
        return 0
      elif $has_pending; then
        print_error "Remaining phases are blocked by dependencies"
        return 1
      else
        print_error "Some phases failed and no more phases can run"
        return 1
      fi
    fi

    log_verbose "main_loop: next runnable phase is $next_phase"

    # Execute the next phase
    if execute_phase "$next_phase"; then
      log_verbose "main_loop: phase $next_phase succeeded, continuing"
      # Success - continue to next phase
      continue
    else
      local _log_file
      _log_file=".claudeloop/logs/phase-${next_phase}.log"
      local _npv
      _npv=$(phase_to_var "$next_phase")
      if is_quota_error "$_log_file"; then
        # Quota error: restore attempt counter (same pattern as handle_interrupt)
        local _cur_attempts
        _cur_attempts=$(eval "echo \"\$PHASE_ATTEMPTS_${_npv}\"")
        eval "PHASE_ATTEMPTS_${_npv}=$((_cur_attempts - 1))"
        eval "PHASE_ATTEMPT_TIME_${_npv}_${_cur_attempts}=''"
        log_verbose "main_loop: quota error on phase $next_phase, attempts restored to $((_cur_attempts - 1))"
        # Reset to pending so find_next_phase picks it up after the wait
        eval "PHASE_STATUS_${_npv}=pending"
        write_progress "$PROGRESS_FILE" "$PLAN_FILE"
        print_quota_wait "$next_phase" "$QUOTA_RETRY_INTERVAL"
        sleep "$QUOTA_RETRY_INTERVAL"
        continue
      fi
      if is_empty_log "$_log_file"; then
        print_error "Phase $next_phase: Claude produced no output (empty log). Check the claude CLI."
        if ! [ -t 0 ] || [ "$YES_MODE" = "true" ]; then
          return 1
        else
          printf 'Press Enter to retry phase %s once the issue is resolved, or Ctrl+C to abort: ' "$next_phase"
          read -r _dummy 2>/dev/null || return 1
        fi
        _cur_attempts=$(eval "echo \"\$PHASE_ATTEMPTS_${_npv}\"")
        eval "PHASE_ATTEMPTS_${_npv}=$((_cur_attempts - 1))"
        eval "PHASE_ATTEMPT_TIME_${_npv}_${_cur_attempts}=''"
        eval "PHASE_STATUS_${_npv}=pending"
        write_progress "$PROGRESS_FILE" "$PLAN_FILE"
        continue
      fi
      if is_permission_error "$_log_file"; then
        print_error "Phase $next_phase: Claude requested write permissions."
        print_warning "Grant the permission in the Claude UI (or re-run with --dangerously-skip-permissions)."
        if ! [ -t 0 ] || [ "$YES_MODE" = "true" ]; then
          return 1
        else
          printf 'Press Enter to retry phase %s, or Ctrl+C to abort: ' "$next_phase"
          read -r _dummy 2>/dev/null || return 1
        fi
        _cur_attempts=$(eval "echo \"\$PHASE_ATTEMPTS_${_npv}\"")
        eval "PHASE_ATTEMPTS_${_npv}=$((_cur_attempts - 1))"
        eval "PHASE_ATTEMPT_TIME_${_npv}_${_cur_attempts}=''"
        eval "PHASE_STATUS_${_npv}=pending"
        write_progress "$PROGRESS_FILE" "$PLAN_FILE"
        continue
      fi
      # Normal error: existing retry logic (unchanged)
      if should_retry_phase "$next_phase"; then
        local _attempts
        _attempts=$(eval "echo \"\$PHASE_ATTEMPTS_${_npv}\"")
        local delay
        delay=$(calculate_backoff "$_attempts")
        log_verbose "main_loop: scheduling retry of phase $next_phase in ${delay}s (attempt $_attempts)"
        print_warning "Retrying phase $next_phase after $delay seconds..."
        sleep "$delay"
        continue
      else
        print_error "Phase $next_phase failed after ${MAX_RETRIES} attempts"
        return 1
      fi
    fi
  done
}

# Monitor mode: follow .claudeloop/live.log of a running claudeloop instance
run_monitor() {
  trap 'printf "\n"; exit 0' INT TERM
  trap - EXIT   # don't run cleanup — monitor never owns the lock

  local _live_log=".claudeloop/live.log"
  local _max_wait="${_MONITOR_WAIT_TIMEOUT:-30}"
  local _wait=0

  while [ ! -f "$_live_log" ]; do
    if [ "$_wait" -ge "$_max_wait" ]; then
      print_error "No live log found in .claudeloop/ after ${_max_wait}s"
      printf 'Start claudeloop first: claudeloop --plan PLAN.md\n'
      exit 1
    fi
    printf 'Waiting for claudeloop to start...\r'
    sleep 1
    _wait=$((_wait + 1))
  done

  local _running=false _lock_pid=""
  if [ -f "$LOCK_FILE" ]; then
    _lock_pid=$(cat "$LOCK_FILE" 2>/dev/null || true)
    [ -n "$_lock_pid" ] && kill -0 "$_lock_pid" 2>/dev/null && _running=true
  fi

  printf '\n'
  if [ "$_running" = true ]; then
    printf '%b● RUNNING%b  PID: %s  |  Plan: %s\n' \
      "$COLOR_GREEN" "$COLOR_RESET" "$_lock_pid" "$PLAN_FILE"
  else
    printf '%b○ COMPLETED%b  Plan: %s\n' \
      "$COLOR_YELLOW" "$COLOR_RESET" "$PLAN_FILE"
  fi
  printf 'Following .claudeloop/live.log — Ctrl+C to stop\n\n'

  if [ -n "${_MONITOR_NO_FOLLOW:-}" ]; then
    tail -n 20 "$_live_log" 2>/dev/null || true
    return 0
  fi

  tail -f "$_live_log"
}

# Main function
main() {
  # Set up signal handlers and cleanup
  trap handle_interrupt INT TERM
  trap cleanup EXIT

  # Load config file (defaults → config file)
  load_config

  # Apply env var overrides (env vars take priority over config file)
  [ -n "$_CL_PLAN_FILE" ]         && PLAN_FILE="$_CL_PLAN_FILE"
  [ -n "$_CL_PROGRESS_FILE" ]     && PROGRESS_FILE="$_CL_PROGRESS_FILE"
  [ -n "$_CL_MAX_RETRIES" ]       && MAX_RETRIES="$_CL_MAX_RETRIES"
  [ -n "$_CL_BASE_DELAY" ]        && BASE_DELAY="$_CL_BASE_DELAY"
  [ -n "$_CL_MAX_DELAY" ]         && MAX_DELAY="$_CL_MAX_DELAY"
  [ -n "$_CL_SIMPLE_MODE" ]       && SIMPLE_MODE="$_CL_SIMPLE_MODE"
  [ -n "$_CL_PHASE_PROMPT_FILE" ]       && PHASE_PROMPT_FILE="$_CL_PHASE_PROMPT_FILE"
  [ -n "$_CL_QUOTA_RETRY_INTERVAL" ]    && QUOTA_RETRY_INTERVAL="$_CL_QUOTA_RETRY_INTERVAL"
  [ -n "$_CL_SKIP_PERMISSIONS" ]        && SKIP_PERMISSIONS="$_CL_SKIP_PERMISSIONS"
  [ -n "$_CL_STREAM_TRUNCATE_LEN" ]     && STREAM_TRUNCATE_LEN="$_CL_STREAM_TRUNCATE_LEN"
  [ -n "$_CL_MAX_PHASE_TIME" ]          && MAX_PHASE_TIME="$_CL_MAX_PHASE_TIME"

  # Parse CLI arguments (CLI takes priority over everything)
  parse_args "$@"

  # Auto-enable non-interactive mode when running inside Claude Code
  if [ -n "${CLAUDECODE:-}" ] && [ "$YES_MODE" = "false" ]; then
    print_warning "Running inside Claude Code — enabling non-interactive mode (--yes)."
    YES_MODE=true
  fi

  print_logo

  # Monitor mode: follow live output of a running instance (never runs setup/execution)
  if [ "$MONITOR_MODE" = "true" ]; then
    run_monitor
    exit 0
  fi

  # Run setup wizard on first launch (no conf, interactive stdin, not dry-run)
  run_setup_wizard

  # Persist settings immediately — before plan file check so conf is always written
  write_config

  # Check if plan file exists
  if [ ! -f "$PLAN_FILE" ]; then
    print_error "Plan file not found: $PLAN_FILE"
    exit 1
  fi

  # Validate phase prompt file if provided
  if [ -n "$PHASE_PROMPT_FILE" ] && [ ! -r "$PHASE_PROMPT_FILE" ]; then
    print_error "Phase prompt file not found or not readable: $PHASE_PROMPT_FILE"
    exit 1
  fi

  # Parse plan
  print_success "Parsing plan file: $PLAN_FILE"
  if ! parse_plan "$PLAN_FILE"; then
    print_error "Failed to parse plan file"
    exit 1
  fi

  echo "Found $PHASE_COUNT phases"

  # Validate environment (skip in dry-run)
  if ! $DRY_RUN; then
    # Infer resume mode from existing progress
    if [ -f "$PROGRESS_FILE" ] && grep -q "Status: completed" "$PROGRESS_FILE" 2>/dev/null; then
      RESUME_MODE=true
    fi
    validate_environment
    setup_project
    # Rotate previous live log (preserves history for debugging)
    LIVE_LOG=".claudeloop/live.log"
    if [ -f "$LIVE_LOG" ]; then
      _ts=$(date '+%Y%m%d-%H%M%S')
      mv "$LIVE_LOG" ".claudeloop/live-${_ts}.log"
    fi
    : > "$LIVE_LOG"
  fi

  # Check for interrupted session (skip in dry-run and reset)
  if ! $DRY_RUN && ! $RESET_PROGRESS; then
    load_state || true
  fi

  # Initialize progress
  if $RESET_PROGRESS; then
    rm -f "$PROGRESS_FILE" "$STATE_FILE"
  fi

  init_progress "$PROGRESS_FILE"

  # Detect and reconcile plan changes (no-op on fresh/reset runs)
  if ! $DRY_RUN && ! $RESET_PROGRESS; then
    detect_plan_changes "$PROGRESS_FILE"
  fi

  # Create lock file (before --phase/--mark-complete so re-init after force-kill is correct)
  if ! $DRY_RUN; then
    create_lock

    # If we force-killed an existing instance, re-read progress to get its final state
    if [ "$FORCE_KILLED" = "true" ]; then
      init_progress "$PROGRESS_FILE"
      if ! $RESET_PROGRESS; then
        detect_plan_changes "$PROGRESS_FILE"
      fi
    fi
  fi

  # Apply --phase N: mark phases before START_PHASE as completed (skip them)
  if [ -n "$START_PHASE" ]; then
    for _p in $PHASE_NUMBERS; do
      phase_less_than "$_p" "$START_PHASE" || break
      eval "PHASE_STATUS_$(phase_to_var "$_p")='completed'"
    done
    log_verbose "main: skipped phases before $START_PHASE (marked completed)"
  fi

  # Apply --mark-complete N: override status of a specific phase to completed
  if [ -n "$MARK_COMPLETE_PHASE" ]; then
    _mc_var=$(phase_to_var "$MARK_COMPLETE_PHASE")
    _mc_title=$(eval "echo \"\${PHASE_TITLE_${_mc_var}:-}\"")
    if [ -z "$_mc_title" ]; then
      print_error "Phase $MARK_COMPLETE_PHASE not found in plan"
      exit 1
    fi
    update_phase_status "$MARK_COMPLETE_PHASE" "completed"
    write_progress "$PROGRESS_FILE" "$PLAN_FILE"
    print_success "Marked phase $MARK_COMPLETE_PHASE as completed"
  fi

  # Print header (after init_progress/detect_plan_changes so completed count is correct)
  print_header "$PLAN_FILE"
  echo ""

  # Print phase list
  print_all_phases

  # Dry run mode
  if $DRY_RUN; then
    print_success "Dry run complete - plan is valid"
    exit 0
  fi

  print_warning "Press Ctrl+C at any time to stop (state will be saved)"
  echo ""

  # Execute phases
  local exit_code=0
  main_loop || exit_code=$?

  # Final progress update
  write_progress "$PROGRESS_FILE" "$PLAN_FILE"

  # Clear state on successful completion
  if [ $exit_code -eq 0 ]; then
    clear_state
  fi

  # Print final summary
  echo ""
  print_header "$PLAN_FILE"
  print_all_phases

  exit $exit_code
}

# Run main (skip if script is sourced for testing)
if [ "${_CLAUDELOOP_SOURCE_ONLY:-0}" != "1" ]; then
  main "$@"
fi
